import java_cup.runtime.*;
import simduino.Coil;
import simduino.Contact;
import simduino.ContactNode;
import simduino.Rung;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;



parser code {:

	public final String PORT_IS_INPUT_OR_OUTPUT="Port is only input or output";
	public final String TYPE_IS_ONLY_0_OR_1="Type is only 0 or 1";
	public final String INVALID_LADDER_DIAGRAM="Invalid ladder diagram";

    private HashMap <Integer,Contact>tableInputPort=new HashMap<>();
    private HashMap <Integer,Coil>tableOutputPort=new HashMap<>();
    private ArrayList<Rung> rungList=new ArrayList<>();

    public HashMap getTableInput(){
    	return tableInputPort;
    }

    public HashMap getTableOutput(){
    	return tableOutputPort;
    }

    public ArrayList<Rung> getRungList(){
    	return rungList;
    }

	public void report_error(String message,Object info){
		System.out.println("Si e' verificato un errore!");
	}

	public void handleError(String message){
	 System.out.println(message);
	 System.exit(1);
	}

	public void report_fatal_error(String message,Object info){
	 report_error(message,info);
	 System.exit(1);
	}

	public int findMax_ToValue_FromContactList(Rung rung){
		int max=0;
		for(Contact cnt: rung.getSection1()){
			if(cnt.getTo()>max){
				max=cnt.getTo();
			}
		}
		return max;
	}


	public void user_init() {

	}

:};



/*----Declaration of Terminal e NonTerminal----*/

terminal QUESTION,EQUAL,DIV,MIN,MAX,XML,PROGRAM,FOR,RUNG,SECTION1,SECTION2,CONTACT,FROM,TO,PORT,COIL,TYPE;
terminal Integer NUM;
terminal String VERSION,ENCODING;

non terminal Object G,F,E,D,B,A,S;
non terminal Integer I;
non terminal String N,P;
start with S;
/*precedence left MIN,RUNG,MAX,DIV;*/


/*Grammar Section*/
S  ::= A 
{:
    Iterator it;

    it = parser.getTableInput().entrySet().iterator();
    while (it.hasNext()) {
        Map.Entry pairs = (Map.Entry)it.next();
        int i=(int)pairs.getKey();
        System.out.println("int pin"+i+"="+i+";");
        System.out.println("int var"+i+"=0;");
    }
    it = parser.getTableOutput().entrySet().iterator();
    while (it.hasNext()) {
		Map.Entry pairs = (Map.Entry)it.next();
        int i=(int)pairs.getKey();
        System.out.println("int pin"+i+"="+i+";");
        if(((Coil)pairs.getValue()).getType()==0)
        	System.out.println("int var"+i+"=LOW;");
        else if(((Coil)pairs.getValue()).getType()==1)
        	System.out.println("int var"+i+"=HIGH;");
        else
        	parser.handleError(parser.TYPE_IS_ONLY_0_OR_1);	
	}


    it = parser.getTableInput().entrySet().iterator();
    System.out.println("void setup(){");
    while (it.hasNext()) {
		Map.Entry pairs = (Map.Entry)it.next();
        int i=(int)pairs.getKey();
        System.out.println("	pinMode("+"pin"+i+","+"INPUT"+");");
	}
	it = parser.getTableOutput().entrySet().iterator();
	while (it.hasNext()) {
		Map.Entry pairs = (Map.Entry)it.next();
        int i=(int)pairs.getKey();
        System.out.println("	pinMode("+"pin"+i+","+"OUTPUT"+");");
	}
	System.out.println("}");

	System.out.println("void loop(){");
	it = parser.getTableInput().entrySet().iterator();
    while (it.hasNext()) {
		Map.Entry pairs = (Map.Entry)it.next();
        int i=(int)pairs.getKey();
        System.out.println("	var"+i+"=digitalRead("+"pin"+i+");");
	}


	ContactNode root;
	it = parser.getRungList().iterator();
	while(it.hasNext()){
	    Object obj = it.next();
		root=new ContactNode((Rung)obj);
		int maxTo=parser.findMax_ToValue_FromContactList((Rung)obj);
		if(!root.buildTree(0,maxTo)){
			parser.handleError(parser.INVALID_LADDER_DIAGRAM);
		}
		/******DEBUG-PRINT TREE*******/
		/*System.out.println("**************************************");
		root.visit();
		System.out.println("**************************************");*/

		System.out.println("	if("+root.toString()+"){");
		if(((Coil)((Rung)obj).getSection2()).getType()==0)
			System.out.println("		"+"var"+((Coil)((Rung)obj).getSection2()).getPort()+"=HIGH;");
		else if(((Coil)((Rung)obj).getSection2()).getType()==1)
			System.out.println("		"+"var"+((Coil)((Rung)obj).getSection2()).getPort()+"=LOW;");
		System.out.println("	}");
	}


	

	/******DEBUG-PRINT RUNG*******/
	/*System.out.println("**************************************");
	Object obj;
	it = parser.getRungList().iterator();
	while(it.hasNext()){
    	obj = it.next();
    	System.out.println("RUNG");
    	Iterator itr = ((Rung)obj).getSection1().iterator();
    	while(itr.hasNext()){
    	 obj = itr.next();
    	 System.out.println("CONTACT");
    	}

	}
	System.out.println("**************************************");*/

	it = parser.getTableOutput().entrySet().iterator();
    while (it.hasNext()) {
		Map.Entry pairs = (Map.Entry)it.next();
        int i=(int)pairs.getKey();
        System.out.println("	digitalWrite("+"pin"+i+","+"var"+i+");");
	}
	System.out.println("}");

:};

A ::= MIN QUESTION XML VERSION EQUAL N ENCODING EQUAL P QUESTION MAX B
{::}; 

B ::= MIN PROGRAM FOR EQUAL I MAX D MIN DIV PROGRAM MAX
{::};

D ::= D MIN RUNG MAX E MIN DIV RUNG MAX
{::};

D ::=
{: :};

E ::= MIN SECTION1 MAX F:section1 MIN DIV SECTION1 MAX MIN SECTION2 MAX G:section2 MIN DIV SECTION2 MAX
{:
 	Rung rung=new Rung((ArrayList<Contact>)section1,(Coil)section2);
 	parser.getRungList().add(rung);
:};

F ::= F:array MIN CONTACT FROM EQUAL I:from TO EQUAL I:to PORT EQUAL I:port TYPE EQUAL I:type DIV MAX
{:

	if(type!=0&&type!=1){
		parser.handleError(parser.TYPE_IS_ONLY_0_OR_1);
	}

 	Contact contact=new Contact(from,to,port,type);
	if(parser.getTableOutput().containsKey(port))
	 parser.handleError(parser.PORT_IS_INPUT_OR_OUTPUT);
	else if(contact.getFrom()+1!=contact.getTo()){
        parser.handleError(parser.INVALID_LADDER_DIAGRAM);         
    }else{
	 if(!parser.getTableInput().containsKey(port)){
	 	parser.getTableInput().put(contact.getPort(),contact);
	 }
	}

	((ArrayList<Contact>)array).add(contact);

	RESULT=array;
:};

F ::=
{:
	ArrayList<Contact> listContact;
	listContact=new ArrayList<>();
	RESULT=listContact;
:};

G ::= MIN COIL PORT EQUAL I:port TYPE EQUAL I:type DIV MAX
{:

	if(type!=0&&type!=1){
		parser.handleError(parser.TYPE_IS_ONLY_0_OR_1);
	}

	Coil coil=new Coil(port,type);
	if(parser.getTableInput().containsKey(port))
	 parser.handleError(parser.PORT_IS_INPUT_OR_OUTPUT);
	else{
	 if(!parser.getTableOutput().containsKey(port)){
	 	parser.getTableOutput().put(coil.getPort(),coil);
	 }
	}
	RESULT=coil;
:};


N ::= VERSION:val {:RESULT=val;:};
I ::= NUM:val {:RESULT=val;:};
P ::= ENCODING:val {:RESULT=val;:};


